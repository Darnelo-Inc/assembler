INFO FROM https://youtube.com/@AlekOS

**_ Как работает оперативная память _**

Бит - минимальная единица памяти
Байт - минимальная ячейка адресации

Для хранения boolean необходимо 1Б, несмотря на то, что он занимает 1 бит

У ячейки Байта есть адрес(байтовая адресация), по которому к нему обращается процессор
У некоторых компьютеров размер ячейки памяти зависит от машинного слова(сколько процессор за раз может обработать байт)
У 32-разрядных процессоров(они для мощных компьютеров, которые работают с большими числами) машинное слово длинной 32 бита
Если процессор обращается к машинному слову, а не к байту, то такая адресация называется "словесная"
В обычных компьютерах одна ячейка памяти равняется 1 Байту

В одном байте изначально было произвольное количество бит. В виду того, что в период развития компьютеров много работали с текстом, в Америке решили, что каждая буква должна помещаться в один байт. Им хватило шести бит, но позже решили, что для удобства кодировки и остальных символов, расширить до восьми. Таким образом, 8 бит в байте - это баланс между рациональным использованием памяти(количества бит в байте) и практическими нуждами(записью символом)

Процессор быстрее обрабатывает данные, используя байтовую адресацию, нежели словесную. Например, задача состоит в том, что нужно поменять букву в слове. При байтовой адресации процессор за одну итерацию обратиться сразу к букве. В случае словесной адресации так не выйдет: за одну итерацию возможно обратиться только к слову

Для работы со строками лучше подходит байтовая адресация, с числами - словесная

Адресация ячеек оперативной памяти происходит в регистрах процессора. Процессор с регистром на n бит может дать адрес 2^n ячейкам(байтам). Таким образом, 32-битный процессор можно работать только с 2^32 Б == 2^22 Кб == 2^12 Мб == 2^2 Гб == 4 Гб

Хранение отрицательных чисел происходит с помощью дополнительного кода: число без знака представляется в двоичном виде, приписываетя бит знака, инвертируются биты без бита знака, прибавляется 1 бит к результату. Оставшиеся биты будут заполнены битом знака(!)

Примитивные типы данных копируются по значению: выделяется такой же участок памяти, как и для начальной переменной
Ссылочные типы данных копируются по ссылке и ссылаются на один и тот же участок памяти. Примером таких данных служат массивы. Статический массив инициализируется на стеке, динамичесий - в куче. Данные хранятся друг за другом, поэтому нужно знать только указатель на первый элемент. Для доступа к элементу нужно знать указатель на массив, индекс элемента и размер данных массива.

**_ Как работает процессор _**

Архитектуры:
x86 - ПК
ARM - мобильные устройства
AVR - микроконтроллеры встроенных систем(машины, телевизоры итд)

Каждая архитектура поддерживает свой набор команд

Разряжность процессора - это величина, которая определяет размер машинного слова. Разрядность процессора совпадает с размером его регистра. Также регистр должен быть кратен ячейки оперативной памяти, т.к. он перемещает их содержимое к себе

Процессоры моделей 8086-80286 имели 16-битную разрядность, модели 80386-... (эти модели называются x86) - 32-битные, модели AMD-64(x86-64) имеют 64-битную разрядность. У Intel 64-разрядные процессоры называются EMT64T

У разных моделей процессоров разное количество регистров. Регистры можно разделить на 2 вида: регистры специального назначения, регистры общего назначения(используются программистами по их усмотрению; в этих регистрах могут храниться переменные, параметры, результаты вычислений). Нам достпны не все регистры

При увеличении размера регистра, "старые" регистры стали располагаться внутри "новых".

В регистрах специального назначения хранится данные разного характера:
в сегментных регистрах(SS, CS, DS ...) хранятся адреса памяти
регистры для работа со стеком(BP, SP ...) указывают на начало фрейма и на верхушку стека
флаговые регистры(FLAGS) содержат разные биты, которые отражают состояние результата предыдущей операции
указатель команд(IP ...) содержит адрес команды, которую нужно выполнить следующей

Если мы в регистрах сложим два числа и результат не поместиться в регист, то произойдёт "круговое" переполнение

После включения компьютера процессор начинает выполнять команды по жесткозаданному адресу. По этому адресу располагается BIOS(Basic input/output system). Его задача - найти первое дисковое устройство, взять оттуда первый сектор, загрузить его в память и передать на него управление, то есть указать процессору на то, чтобы теперь он выполнял команды по адресу этой загруженной программы. Этой программой является Операционная Система, которая в дальнейшем переводит процессор в защищённый режим, далее реализуется многозадачность, работа с памятью, выставляются различные ограничения итд

При запуску любой программы, операционная система выделяет под неё оперативную память, после чего передаёт ей управление. Передать управление - это значит сказать процессору, с какого места из памяти ему выполнить следующую команду. Тут используется регистр IP. По ходу программы этот IP сдвигается по инструкциям.

Адрес ячейки памяти, выставляемый программой, и действительной ячейки могут отличаться из-за соображений безопасности

Процессор может работать в нескольких режимах:

1. Режим реальных адресов (16 бит) - в этот режим процессор переходит сразу после включения компьютера. Адреса, сформированные программой, и действительные совпадают. В каждый момент может выполняться только одна программа. Вся память делится на сегменты в 64 Кб
2. Защищённый (32 бит). В него можно перейти только из режим реальных адресов. Это делает операционная система, выставляя специальный флаг системного регистра, устранавливает разрешения для других программ. Этот режим реализует защиту следующим образом: разделяет приложение на разные уровни привилегий; процессор следит, чтобы програмы не получали доступ к запретным участкам памяти и не использовали любые команды(работа привилегий). При нарушении поведения программы, процессор генерирует исключение и передаёт управление оперативной системе, чтобы та приняла меры. Вся память делится на сегменты в 4 Гб. Работает механизм трансляции виртуальных адресов в физические
3. 64-разрядный режим (64 бита). В него можно перейти только из защищённого режима. В нём используется та же защита. Отключена сегментация памяти. Доступно 2^52 Б физической памяти и 2^48 Б виртуальной памяти. Эти ограничения обусловлены архитектурой процессора и операционной системы

Для второго и третьего режим существует 4 уровня привилегий:
0 уровень - полный доступ к процессору. На нем работает операционная система
1 уровень
2 уровень
3 уровень - пользовательский
Запреты верхних уровней распространяются на нижние

Вся оперативная память поделена на условные сегменты - участки памяти определенного размера. Размер зависит от режима процессора. Адрес участка представляется программами в специальной форме(для режима реальных адресов):
логический адрес = адрес начала сегмента(16 бит) : смещение в сегменте(16 бит)

Этот адрес преобразовывается в физический адрес:
физический адрес(20 бит) = адрес начала сегмента << 4 + смещение в сегменте
Может адресовать 2^20 адресов, то есть 1 Мб физической памяти.

Использование двух типов адресов, логического и физического, позволяет достичь различных преимуществ:

1. Абстракция: Логический адрес предоставляет программам абстракцию от физической памяти компьютера. Это позволяет программам работать с данными, не зная о конкретных физических адресах и местоположении данных в памяти. Это облегчает разработку программ и повышает их переносимость между различными системами.

2. Защита: Использование логического адреса позволяет операционной системе контролировать доступ программ к памяти. Операционная система может установить различные права доступа для разных программ или сегментов памяти, что повышает безопасность и защиту данных.

3. Управление памятью: Операционная система может эффективно управлять физической памятью, используя логический адрес. Она может использовать механизмы виртуальной памяти, такие как страничная трансляция, для оптимального распределения и управления доступом к данным в памяти.

4. Поддержка большего объема памяти: Логический адрес может быть больше, чем физический адрес, что позволяет адресовать больший объем памяти, чем доступно физической памяти на компьютере. Это особенно полезно в системах с ограниченным объемом физической памяти или в случае использования виртуальной памяти.

Таким образом, использование логического и физического адресов позволяет достичь абстракции, защиты, управления памятью и поддержки большего объема памяти в процессорах.

Логический адрес может быть больше физического адреса благодаря механизму виртуальной памяти. Виртуальная память позволяет операционной системе создать иллюзию большего объема памяти, чем физически доступно на компьютере.

Когда программа обращается к логическому адресу, операционная система использует механизмы виртуальной памяти для перевода этого адреса в соответствующий физический адрес. Операционная система может разбить логическую память на блоки, называемые страницами, и хранить эти страницы в физической памяти или на диске.

Таким образом, даже если физическая память ограничена, операционная система может загружать и выгружать страницы из физической памяти во внешнее хранилище (например, на жесткий диск) по мере необходимости. Это позволяет программам работать с логическим адресом, который может быть больше, чем доступное количество физической памяти.

Использование виртуальной памяти имеет ряд преимуществ, таких как более эффективное использование физической памяти, возможность запуска программ, требующих большего объема памяти, и защита данных от несанкционированного доступа. Однако, при использовании виртуальной памяти может возникать некоторая накладная нагрузка на производительность из-за необходимости выполнения дополнительных операций по переводу логических адресов в физические.

В защищенном режиме логический адрес формируется следующим образом:
логический адрес = селектор дескриптора(16 бит) : смещение в сегменте(32 бита)

Селектор дескриптора представляет собой индекс дескриптора, в котором указывается начальный адрес сегмента, уровень привилегий и размер сегмента. Это все находится в специальных дескрипторных таблицах. Из дескриптора извлекается адрес сегмента, к нему прибавляется смещение в сегмента, и получается виртуальный адрес(32 бита). Таким образом, логический адрес преобразовывается в виртуальный, при условии, что включен механизм трансляции адресов. В противном случае, этот адрес будет физическим

Виртуальный адрес поздразумевает существование виртуальной памяти. Такая сущность получила название "страничная организация памяти": все адресное пространство разбивается на страницы непрерываной области памяти(размер зависит от режима процессора и от режима трансляции адресов). Сами страницы хранятся в таблице страниц, которые в свою очередь, хранятся в каталоге страниц. Таким образом, виртуальный адрес делится на три части:

1. индекс в каталоге страниц(из которого выделяется физический адрес таблицы страницы)
2. индекс в таблице страниц(из которого выделяется физический адрес страницы)
3. смещение в странице
   Затем с помощью механизма трансляции адресов происходит преобразование виртуального адреса в 32-битный физический. Можно адресовать 2^32 Б = 2^22 Кб = 2^12 Мб = 2^2 Гб = 4 Гб

Резюмируем главу по адреса: в ходе выполнения программы ей надо обращаться к оперативной памяти. Она формирует логический адрес, по которому происходит обращение. В зависимости от режима работы процессора, это адрес сразу преобразовывается в физический или после преобразования в виртуальный

Для обращения к процессору(например через клавиатуру) контроллер прерываний. Прерывание - это сигнал процессору о том, чтобы он прервал выполнение текущей программы и передал управление специальной функции-обработчику прерывания(обычная программа). Прерываемая программа продолжается после заверешения работы функции-обработчика путем сохранения в память адреса команды, которую она сделает следующей

**_ Как работает стек _**

Вся оператиная память делится на стек и кучу
Стек(аппаратный, не путать со структурой данных) - это специально отведенная область оперативной памяти для хранения временных данных. Благодаря ему возможно вызывать подпрограммы. В куче хранятся работающие программы и они хранятся линейно от начала памяти. Стек же хранится в обратном порядке: начинается где-то в памяти и до начала памяти

Каждый элемент стека занимает одно машинное слово. SP - stack pointer - указатель на верхушку стека. BP - base pointer - указатель на начало фрейма стека, используется для получения параметров в стеке, на протяжении выполнения функции статичен (если не вызывались подрограммы). Оба указателя хранятся в соответствующих регистрах

Для работы со стеком есть две основыные команды: push - поместить данные на верхушку стека, pop - извлечь данные с верхушки стека

Например, в стек нужно поместить число 3. У указателя SP нужно отнять величину машинного слова, затем в "передвинутый" SP поместить число 3. Команда pop работает в обратном порядке. pop ax - вернуть данные с вершины стека в регистр ax, а к указателю SP нужно прибавить величину машинного слова

Функции - подпрограммы, расположенные в разных частях памяти. У каждой функции есть свой адрес начала, по которому она расположена. Используя эти адреса, одна функция может передать управление другой. Кроме переходов необходимо также иметь возможность передавать параметры функции, использовать локальные переменные и после отработки передавать управление вызывающей функции

Для перехода между подпрограммами в Ассемблере есть несколько основных команд:
jmp - прыгает из одного участка кода в другой по указанному в операнде адресу
call - перед тем, как перескочить, записывает в стек адрес возврата, который указан в операнде
ret - используется для возврата внутри вызываемой функции после того, как та отработала. Она вытаскивает из стека адрес возврата и переходит по нему

Область конкретной функции в стеке называется "фреймом функции", внутри которой находятся её локальное окружение

Перед вызовом подпрограммы в стек сохраняется старый адрес BP (push bp), чтобы после выполнения вызываемой функции мы продолжили выполнение исходной функции. Далее мы должны поднять BP на самый верх, копируя его в SP (mov bp, sp). Дальше в стек буду добавлять локальные переменные функции (push 4, push 5.5, push str). BP по-прежнему в ячейке, где хранится адрес старого BP

При окончании выполнения подпрограммы переносим SP в BP (mov sp, bp). Затем мы извлекаем bp с вершины стека (pop bp) и перемещаем на его старый адрес. SP всё это время перемещается по верхам стека. Таким образом мы восстановили состояние регистров sp, bp до того момента, как была вызвана подпрограмма (SP указывает на адрес возврата(который бал помещен туда командой call), BP на начало фрейма исходной функции). Осталось вызвать команду ret, которая извлечет из стека адрес возврата и перейдет по нему

Бесконечная рекурсия вызывает переполнение стека, так как постоянно будут сохранятся адрес возврата и старый адрес BP

Передачу параметров можно осуществлять с помощью стека. В основном использует прицнип call std, когда параметры передаются в обратном порядке(push 3, push 2, push 1), а затем записывает адрес возврата(call f) и старый адрес ВP(push bp, mov bp,sp). В следствии чего для получения параметров(в 16 битном режиме процессора) используем следующие команды: mov ax,[bp+4], mov bx,[bp+6], mov cx,[bp+8]

После отработки функции параметры больше не нужны и их может очистить(переместить SP на то место, где он был до передачи параметров) вызываемая или вызванная подпрограмма:
-вызываемая программа: mov sp,bp, pop bp, ret 6. Тут 6 обозначает сколько байт нужно удалить из стека после удаления адреса возврата(у нас три параметра по 2 байта каждый)
-вызванная программа(когда нужно выполнить несколько команд с одинаковым набором параметров): после команды ret SP будет указывать на последний переданный параметр. Поэтому необходимо его сдвинуть на количество битов, занимаемые параметрами(add sp,6)

Обычно локальные переменные хранятся в стеке. Область, которая под них отводится, называется "стековый фрейм". При вызове функции формируется этот самый стековый фрейм путем перемещения BP на вершину стека. Функция выделяет себе память в стеке с помощью сдвига SP на нужное количество байт. Адресация к локальным переменным производится с помощью указателя BP(тот же метод, что и для параметров). Например, чтобы задать локальную переменную 10, нужно выполнить команду mov [bp-2],10. Если вторую хотим str, то mov [bp-4],str. При заверешении функции эти переменные удаляться путем сдвига SP

**_ Язык Ассемблера _**

На языке Ассемблера пишут драйверы, компиляторы, оперативные системы ввиде нескольких причин: доступ к аппаратуре, минимальный размер программы, высокая скорость выполнения

Набор инструкций - то, в что превратиться программа после трансляции
Язык Ассемблера - набор инструкций в символическом виде, в них превращается любая программа. Этот язык не идёт в сравнении с другими языками более высокого уровня, так как говорить, что дом хорош и без фундамента - абсурдно

Язык Ассемблера = Я хочу разобраться как работает мой код!!!

Программа на Ассемблере - это программа без абстракций. С помощью этого языка, можно понять, как работает компьютер

Ассемблер по умолчанию содержит команды для процессора 8086. В нем нельзя использовать команды для процессоров "старше", если не указать директиву, обозначающую модель процессора - .8086, .186, .286 итд

Процессор может работать в трех режимах: режим реальных адресов (16 бит), защищённый режим (32 бит), long mode (64 бита). Для полного доступа к памяти будем работать в режиме реальных адресов, так как в остальных програама помещается в виртуальную память и на неё накладываются ограничения

Есть два синтаксиса для Ассемблера:
Intel: mov ax,5
AT&T: movw 5,%ax (b - (byte) операнды размером 1 байт, w - (word) размером 1 слово, l - (ling) размером 4 байта)

Программа в памяти поделена на 3 сегмента:
сегмент кода (инструкции программы)
сегмент данных (глобальные переменные)
сегмент стека

Распологаются сегменты в памяти не по порядку. Их адреса назначает операционная система, сами сегменты располшает компоновщик. Эти адреса мы можем использовать в коде для взаимодействия сегментов друг с другом. Например, из сегмента кода, мы хотим прочитать данные из сегмента данных. Тогда необходимо сформировать логический адрес - адрес сегмента и смещенение в этом сегменте. Адреса сегментов хранятся в регистрах CS(code segment), DS(data segment), SS(stack segment), ES GS FS(сегменты доп данных). Смещение представляет из себя название метки, что-то в роде названия переменной. Адреса 16-битные(работаем в режиме реальных адресов), поэтому адреса являются 16-битными числами. В следствие этого, в каждый сегмент помещается максимум 64 Кб

Чтобы процессор смог обратиться к реальной ячейки памяти, он формирует физический адрес, путем смещения адреса сегмента на 4 бита влево (умножение на 16) и прибавляя смещение. У процессора 8086 была 20-битная шина адреса, поэтому физический адрес имеет такой вид. С помощью 20 бит можно адресовать 1 Мб памяти. Каждый сегмент имеет минимальный размер в 16 байт из-за сдвига сегментного адреса на 4 бита, если использовать нулевые смещения

Создаются сегменты с помощью директивы SEGMENT(первый способ). Сначало мы задаём имя сегмента, которое в дальнейшем будет использовано для получения сегментного адреса, далее ключевое слово SEGMENT. После могут идти 4 необязательных параметра(конфигурация хранения в памяти) - разрядность, выравнивание, класс, тип. Далее ставится закрывающаяся конструкция code ends. Между ними пишется код, предназначенный для данного сегмента.

Разрядность - размер регистров, адресов. Он может принимать два параметра: USE16(по умолчанию для процессоров ниже 80386) - 16 бит(именно в этом случае размер сегмента не превысит 64 Кб), USE32(по умолчанию для процессоров выше 80386 включая) - 32 бита(размер сегмента может быть до 4 Гб)

Выравнивание - подсказывает компилятору, как выравниввать адреса сегментов. При пересечении границы процессору понадобиться более одного обращения к памяти, так как границы изначально кратны размеру байта.

byte - по любому адресу
word - кратны 2
dword - кратны 4
para - кратны 16
page - кратны 256

Класс - придуманная нами метка в кавычках. Это порядок следования сегментов в памяти. Все сегменты одного класса будут располагаться в памяти друг за другом. Например, это полезно для объединения всех сегментов данных

Тип - говорит компоновщику, как комбинировать сегменты с одинаковым именем. PUBLIC - все сегменты с одинаковым именем будут объединены в один. В одном модуле все сегменты с одинаковым именем и одинаковым типом обрабатываются так, как если бы мы объявляли один сегмент с таким именем. Под модулем подразумевается отдельно взятый файл программы на Ассемблере. Программа может состоять из нескольких файлов, то есть модулей. В таком случае параметр "тип" определяет, как сегменты из разных модулей должны объединяться между собой. Сегменты с типом PRIVATE, который используется по умолчанию, не будут объединяться в один. Тип STACK определяет сегмент стека программы и по аналогии с типом PUBLIC все одноименные сегменты с типом STACK будут объединяться в один

Адреса некоторых сегментов нужно загружать в сегментые регистры вручную. Напрямую это делать нельзя. Нужно передать адрес в любой другой неадресный регистр, а затем в адресный. Пример:

data SEGMENT
data ends

Неверно:
mov ds, data

Верно:  
 mov ax, data
mov ds, ax

Несмотря на то, что программа делится на три основных сегмента - код, данные и стек. В ней могут быть задействованы сразу по нескольку сегментов, которые можно объединять в группы. Например:

data1 SEGMENT
...
data1 ends

---

data2 SEGMENT
...
data2 ends

---

data3 SEGMENT
...
data4 ends

Их адреса мы можем раскидывать по сегментным регистрам данных, либо объединить в одну группу, задав ей имя:
DGROUP group data1, data2, data3
Далее mov ax, DGROUP
mov ds, ax
В таком случае адреса сегментов будут вычисляться относительно начала этой группы

Сами регистры не несут компилятору информации о их назначении. Поэтому, чтобы явно сообщить компилятору, какой из этих сегментов или группы сегментов будет относиться к CS, какой к DS, а какой к SS, нужно использовать директиву ASSUME внутри сегмента перед первой командой. Пример:

code SEGMENT
ASSUME CS:code, DS:data, SS:stack
...
code ends
data SEGMENT
...
data ends
stack SEGMENT
...
stack ends

ASSUME используется как подсказка. То есть, указав, что DS:data, мы в дальнейшем не перезапишем этот регистр. Например, у нас объявлены два сегмента данных - d1, d2. d1 в регистре ds, d2 в es. В сегменте кода мы обращаемся к данным из d2 - к переменной var, указывая только имя метки(mov dl, var). var - смещение данных в втором сегменте данных. Ассемблер обнаруживает метку с таким названием, но чтобы к нему обратиться, компилятору нужно знать адрес сегмента. Он это возьмет как раз из ASSUME(ASSUME CS:code, DS:d1, ES:d2)

Если в ходе программы меняем адреса в сегментных регистрах, то необходимо повторно использовать директиву ASSUME

Мы может создать несколько сегментов для кода, данных или стека. Все это формирует модель памяти, которую будет использовать программа. С целью автоматического комбинирования сегментов памяти, в компилятор была добавлена директива .model. В качестве операнда она принимает одну из предложенных названий моделей(tiny | small | compact | medium | large | huge | flat). Некоторые из них были актуальны, пока использовалась сегментация памяти. Сейчас в 32-битных системах программы(код, данные и стек) находятся в одном большом сегменте памяти, где 32-битные сегменты(до 4 Гб) и адреса - модель flat. В dos её использовать нельзя, так как находимся в 16-битном режиме. Используем tiny - аналог flat для dos. Используя её, весь код программы, данные и стек будут помещены в один сегмент, который не превышает 64 Кб. Остальные модели различные комбинирования сегментов памяти. Модель small позволяет использовать в программе несколько сегментов. По одному на сегмент кода, данные и стек, но последние два в группу, то есть DS и SS указывает на один и тот же сегмент. Использование моделей позволяет объявить сегменты вторым способом. Каждая из этих директив это укороченная аналогом объявление сегментов через SEGMENT(первый способ). Эти директивы не нужно закрывать. Сегмент будет считаться законченным, когда будет найдена следующая директива SEGMENT или конец программы
